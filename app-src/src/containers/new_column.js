import React, { Component } from "react";
import {
  addColumnToKey,
  fetchColumn,
  getAutoGeneratedNamesForKey,
  setDataTypeComplex,
  updateAutoGeneratedNamesForKey
} from "../actions/tables";
import {
  finishTransaction,
  getCurrentHistoryTransaction,
  startTransaction
} from "../actions/undoredo";

import { ClassColumnGraphQl } from "../platforms/graphql/class_column_graphql";
import { ClassColumnJson } from "../platforms/json/class_column_json";
import { ClassColumnJsonSchema } from "../platforms/jsonschema/class_column_jsonschema";
import { ClassColumnLogical } from "../platforms/logical/class_column_logical";
import { ClassColumnMSSQL } from "../platforms/mssql/class_column_mssql";
import { ClassColumnMongoDb } from "../platforms/mongodb/class_column_mongodb";
import { ClassColumnMongoose } from "../platforms/mongoose/class_column_mongoose";
import { ClassColumnMySQLFamily } from "../platforms/mysql_family/class_column_mysql_family";
import { ClassColumnPG } from "../platforms/pg/class_column_pg";
import { ClassColumnSQLite } from "../platforms/sqlite/class_column_sqlite";
import { ClassColumnSequelize } from "../platforms/sequelize/class_column_sequelize";
import { CompositeDependencies } from "../platforms/pg/composite_dependencies";
import JsonHelpers from "../platforms/json/helpers_json";
import JsonSchemaHelpers from "../platforms/jsonschema/helpers_jsonschema";
import { ModelTypes } from "../enums/enums";
import MongoDbHelpers from "../platforms/mongodb/helpers_mongodb";
import MongooseHelpers from "../platforms/mongoose/helpers_mongoose";
import NewColumnGraphQl from "../platforms/graphql/new_column_graphql";
import NewColumnLogical from "../platforms/logical/new_column_logical";
import NewColumnMSSQL from "../platforms/mssql/new_column_mssql";
import NewColumnMongoDb from "../platforms/mongodb/new_column_mongodb";
import NewColumnMongoose from "../platforms/mongoose/new_column_mongoose";
import NewColumnMySQLFamily from "../platforms/mysql_family/new_column_mysql_family";
import NewColumnPG from "../platforms/pg/new_column_pg";
import NewColumnSQLite from "../platforms/sqlite/new_column_sqlite";
import NewColumnSequelize from "../platforms/sequelize/new_column_sequelize";
import { OtherObjectTypes } from "common";
import { UndoRedoDef } from "../helpers/history/undo_redo_transaction_defs";
import _ from "lodash";
import { bindActionCreators } from "redux";
import { connect } from "react-redux";
import { existsTableCycle } from "../helpers/cycle_detection";
import { getEmbeddableWithColsList } from "../selectors/selector_tables";
import { getHistoryContext } from "../helpers/history/history";
import { getReducedOtherObjectsList } from "../selectors/selector_other_objects";
import { isPerseid } from "../helpers/features/features";
import { v4 as uuidv4 } from "uuid";
import { withRouter } from "react-router-dom";

class NewColumn extends Component {
  constructor(props) {
    super(props);
    this.compositeDependencies = new CompositeDependencies();
    this.state = {
      valueName: "",
      valueDatatype: "",
      valueParam: "",
      valuePk: false,
      valueNn: false,
      valueList: false
    };

    this.handleStateChange = this.handleStateChange.bind(this);
  }

  handleStateChange(paramName, paramValue) {
    this.setState({ [paramName]: paramValue });
  }

  getTargetObject() {
    return this.props.passedTableId ?? this.props.match.params.id;
  }

  createColByPlatform(platform) {
    let newCol;
    switch (platform) {
      case "MONGODB":
        newCol = new ClassColumnMongoDb(
          uuidv4(),
          this.state.valueName,
          this.state.valueDatatype,
          this.state.valuePk,
          this.state.valueNn,
          this.state.valueList
        );
        return newCol;
      case "GRAPHQL":
        newCol = new ClassColumnGraphQl(
          uuidv4(),
          this.state.valueName,
          this.state.valueDatatype,
          this.state.valuePk,
          this.state.valueNn,
          this.state.valueList,
          null,
          false,
          false
        );
        return newCol;
      case "MONGOOSE":
        newCol = new ClassColumnMongoose(
          uuidv4(),
          this.state.valueName,
          this.state.valueDatatype,
          this.state.valuePk,
          this.state.valueNn,
          this.state.valueList
        );
        return newCol;
      case "SEQUELIZE":
        newCol = new ClassColumnSequelize(
          uuidv4(),
          this.state.valueName,
          this.state.valueDatatype,
          this.state.valuePk,
          this.state.valueNn,
          this.state.param
        );
        return newCol;
      case ModelTypes.MARIADB:
      case ModelTypes.MYSQL:
        return this.getTargetObject() &&
          this.props.tables[this.getTargetObject()].embeddable === false
          ? new ClassColumnMySQLFamily(
              uuidv4(),
              this.state.valueName,
              this.state.valueDatatype,
              this.state.valuePk,
              this.state.valueNn,
              this.state.valueParam
            )
          : this.createNewJSONColumn();
      case "SQLITE":
        if (
          this.getTargetObject() &&
          this.props.tables[this.getTargetObject()].embeddable === false
        ) {
          newCol = new ClassColumnSQLite(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueParam,
            this.props.def_collation
          );
        } else {
          newCol = new ClassColumnJson(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueList
          );
        }
        return newCol;
      case "PG":
        if (
          this.getTargetObject() &&
          this.props.tables[this.getTargetObject()].embeddable === false
        ) {
          newCol = new ClassColumnPG(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.props.tables[this.getTargetObject()].objectType === "composite"
              ? false
              : this.state.valuePk,
            this.props.tables[this.getTargetObject()].objectType === "composite"
              ? false
              : this.state.valueNn,
            this.state.valueParam,
            this.state.valueList
          );
        } else {
          newCol = new ClassColumnJson(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueList
          );
        }
        return newCol;
      case "MSSQL":
        if (
          this.getTargetObject() &&
          this.props.tables[this.getTargetObject()].embeddable === false
        ) {
          newCol = new ClassColumnMSSQL(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueParam,
            this.state.valueList
          );
        } else {
          newCol = new ClassColumnJson(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueList
          );
        }
        return newCol;
      case "LOGICAL":
        if (
          this.getTargetObject() &&
          this.props.tables[this.getTargetObject()].embeddable === false
        ) {
          newCol = new ClassColumnLogical(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueParam
          );
        } else {
          newCol = new ClassColumnJson(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueList
          );
        }
        return newCol;
      case ModelTypes.JSONSCHEMA:
      case ModelTypes.FULLJSON:
      case ModelTypes.OPENAPI:
        if (
          this.getTargetObject() &&
          this.props.tables[this.getTargetObject()].embeddable === false
        ) {
          newCol = new ClassColumnJsonSchema(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueParam
          );
        } else {
          newCol = new ClassColumnJson(
            uuidv4(),
            this.state.valueName,
            this.state.valueDatatype,
            this.state.valuePk,
            this.state.valueNn,
            this.state.valueList
          );
        }
        return newCol;
      default:
        return undefined;
    }
  }

  createNewJSONColumn() {
    return new ClassColumnJson(
      uuidv4(),
      this.state.valueName,
      this.state.valueDatatype,
      this.state.valuePk,
      this.state.valueNn,
      this.state.valueList
    );
  }

  async addNewColumnToActiveTable() {
    var newCol = this.createColByPlatform(this.props.type);
    await this.props.fetchColumn(
      newCol,
      this.getTargetObject(),
      _.size(this.props.tables[this.getTargetObject()].cols)
    );
    if (this.props.type === ModelTypes.MONGODB) {
      if (newCol.datatype === MongoDbHelpers.getMongoDBHierarchyType()) {
        await this.props.setDataTypeComplex(
          getHistoryContext(this.props.history, this.props.match),
          newCol.id,
          this.getTargetObject(),
          newCol.datatype,
          MongoDbHelpers.getMongoDBHierarchyType()
        );
      }
    }

    if (this.props.type === ModelTypes.MONGOOSE) {
      if (newCol.datatype === MongooseHelpers.getMongooseHierarchyType()) {
        await this.props.setDataTypeComplex(
          getHistoryContext(this.props.history, this.props.match),
          newCol.id,
          this.getTargetObject(),
          newCol.datatype,
          MongooseHelpers.getMongooseHierarchyType()
        );
      }
    }

    if (this.state.valuePk === true) {
      var clnActvTbl = this.props.tables[this.getTargetObject()];
      var tablePk = _.find(clnActvTbl.keys, ["isPk", true]);
      const autoGeneratedNames = getAutoGeneratedNamesForKey({
        settings: {
          type: this.props.type,
          nameAutoGeneration: this.props.nameAutoGeneration
        },
        tables: this.props.tables,
        table: clnActvTbl,
        key: tablePk,
        relations: this.props.relations
      });
      await this.props.addColumnToKey(
        this.getTargetObject(),
        newCol.id,
        this.getTargetObject(),
        tablePk.id
      );
      await this.props.updateAutoGeneratedNamesForKey(autoGeneratedNames);
    }

    this.setState({ valueName: "" });

    getCurrentHistoryTransaction().addResizeRequest({
      operation: "addNewColumnToActiveTable",
      domToModel: true,
      autoExpand: true,
      objects: [this.getTargetObject()]
    });
  }

  async handleNewColSubmit(event) {
    let persistedEvent = event;
    persistedEvent.preventDefault();
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.NEW_COLUMN__ADD_NEW_COLUMN
    );
    try {
      await this.addNewColumnToActiveTable();
    } finally {
      await this.props.finishTransaction();
    }
  }

  renderEmbeddable(tableId) {
    let tableToRemoveFromList = tableId ? tableId : this.getTargetObject();
    var embeddableTables = _.filter(this.props.tables, ["embeddable", true]);
    embeddableTables = _.reject(embeddableTables, [
      "id",
      tableToRemoveFromList
    ]);

    if (isPerseid(this.props.profile)) {
      embeddableTables = _.filter(embeddableTables, function (o) {
        return JsonSchemaHelpers.isRootOrDef(o);
      });
    }

    return _.map(embeddableTables, (tx) => {
      if (
        existsTableCycle(this.props.tables, tx, tableToRemoveFromList) === false
      ) {
        return (
          <option key={tx.id} value={tx.id}>
            {tx.name + " (" + this.props.localization.L_TABLE_EMBEDDABLE + ")"}
          </option>
        );
      }
    });
  }

  renderEmbeddableForSchemas() {
    return _.map(this.props.tableEmbeddableWithColsArray, (table) => {
      if (
        existsTableCycle(this.props.tables, table, this.getTargetObject()) ===
        false
      ) {
        return (
          <option
            key={uuidv4()}
            value={table.id}
            className="im-datatypes-tables"
          >
            {table.name +
              " (" +
              this.props.localization.L_TABLE_EMBEDDABLE +
              ")"}
          </option>
        );
      }
    });
  }

  renderDomains() {
    return Object.keys(this.props.otherObjectsArray)
      .map((key) => this.props.otherObjectsArray[key])
      .filter((otherObject) => otherObject.type === "Domain")
      .map((domain) => (
        <option
          key={"c_" + domain.id}
          value={domain.id}
          className="im-datatypes-tables"
        >
          {domain.name + " (domain)"}
        </option>
      ));
  }

  renderEnums() {
    return Object.keys(this.props.otherObjectsArray)
      .map((key) => this.props.otherObjectsArray[key])
      .filter((otherObject) => otherObject.type === "Enum")
      .map((enu) => (
        <option
          key={"c_" + enu.id}
          value={enu.id}
          className="im-datatypes-tables"
        >
          {enu.name + " (enum)"}
        </option>
      ));
  }

  renderTypes() {
    return Object.keys(this.props.otherObjectsArray)
      .map((key) => this.props.otherObjectsArray[key])
      .filter((otherObject) => otherObject.type === "TypeOther")
      .map((type) => (
        <option
          key={"c_" + type.id}
          value={type.id}
          className="im-datatypes-tables"
        >
          {type.name + " (type)"}
        </option>
      ));
  }

  renderUserDefinedTypes() {
    return Object.keys(this.props.otherObjectsArray)
      .map((key) => this.props.otherObjectsArray[key])
      .filter(
        (otherObject) => otherObject.type === OtherObjectTypes.UserDefinedType
      )
      .map((type) => (
        <option
          key={"c_" + type.id}
          value={type.id}
          className="im-datatypes-tables"
        >
          {type.name + " (UDT)"}
        </option>
      ));
  }
  renderComposites() {
    const composites = Object.keys(this.props.tables)
      .map((key) => this.props.tables[key])
      .filter((table) => table.objectType === "composite");
    const notCycledComposites = this.compositeDependencies.notCycledComposites(
      composites,
      this.props.tables[this.getTargetObject()].objectType === "composite"
        ? this.props.tables[this.getTargetObject()]
        : null
    );
    return notCycledComposites.map((composite) => (
      <option
        key={"c_" + composite.name}
        value={composite.id}
        className="im-datatypes-tables"
      >
        {composite.name + " (composite)"}
      </option>
    ));
  }

  renderCustomDatatypes() {
    if (this.props.customDataTypes) {
      return _.map(this.props.customDataTypes, (customDataType) => {
        return (
          <option
            key={"c_" + customDataType}
            value={customDataType}
            className="im-datatypes-tables"
          >
            {customDataType}
          </option>
        );
      });
    }
  }

  renderSchemas() {
    var embeddableTables = _.filter(this.props.tables, ["embeddable", false]);
    embeddableTables = _.sortBy(embeddableTables, ["name"]);
    embeddableTables = _.reject(embeddableTables, [
      "id",
      this.getTargetObject()
    ]);
    return _.map(embeddableTables, (table) => {
      if (
        existsTableCycle(this.props.tables, table, this.getTargetObject()) ===
        false
      ) {
        return (
          <option
            key={uuidv4()}
            value={table.id}
            className="im-datatypes-tables"
          >
            {table.name + " (" + this.props.localization.L_TABLE + ")"}
          </option>
        );
      }
    });
  }

  renderOtherObjects(objectType, objectTypeName) {
    var otherObjectsList = _.filter(this.props.otherObjectsArray, [
      "type",
      objectType
    ]);
    otherObjectsList = _.sortBy(otherObjectsList, ["name"]);
    return _.map(otherObjectsList, (otherObjectItem) => {
      return (
        <option
          key={uuidv4()}
          value={otherObjectItem.id}
          className="im-datatypes-tables"
        >
          {otherObjectItem.name + " (" + objectTypeName + ")"}
        </option>
      );
    });
  }

  renderDataTypesJson(fn, colDatatype) {
    return (
      <select value={colDatatype} onChange={fn}>
        {JsonHelpers.makeDatatypesJson()}
        {this.renderEmbeddable()}
        {this.renderCustomDatatypes()}
      </select>
    );
  }

  renderNewColumnByPlatform(platform) {
    switch (platform) {
      case "MONGODB":
        return (
          <NewColumnMongoDb
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderSchemas={this.renderSchemas.bind(this)}
          />
        );

      case "GRAPHQL":
        return (
          <NewColumnGraphQl
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderEmbeddableForSchemas={this.renderEmbeddableForSchemas.bind(
              this
            )}
            renderSchemas={this.renderSchemas.bind(this)}
            renderOtherObjects={this.renderOtherObjects.bind(this)}
          />
        );

      case "MONGOOSE":
        return (
          <NewColumnMongoose
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderEmbeddableForSchemas={this.renderEmbeddableForSchemas.bind(
              this
            )}
            renderEnums={this.renderEnums.bind(this)}
            renderSchemas={this.renderSchemas.bind(this)}
          />
        );
      case "SEQUELIZE":
        return (
          <NewColumnSequelize
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
          />
        );
      case ModelTypes.MARIADB:
      case ModelTypes.MYSQL:
        return (
          <NewColumnMySQLFamily
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
          />
        );
      case "SQLITE":
        return (
          <NewColumnSQLite
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
          />
        );
      case "LOGICAL":
        return (
          <NewColumnLogical
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
          />
        );

      case "PG":
        return (
          <NewColumnPG
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderDomains={this.renderDomains.bind(this)}
            renderEnums={this.renderEnums.bind(this)}
            renderTypes={this.renderTypes.bind(this)}
            renderComposites={this.renderComposites.bind(this)}
          />
        );

      case "MSSQL":
        return (
          <NewColumnMSSQL
            passedTableId={this.getTargetObject()}
            valueDatatype={this.state.valueDatatype}
            newColName={this.state.valueName}
            handleStateChange={this.handleStateChange.bind(this)}
            handleNewColSubmit={this.handleNewColSubmit.bind(this)}
            renderUserDefinedTypes={this.renderUserDefinedTypes.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
          />
        );

      default:
        return <></>;
    }
  }

  render() {
    return (
      <React.Fragment>
        {this.renderNewColumnByPlatform(this.props.type)}
      </React.Fragment>
    );
  }
}

function mapStateToProps(state) {
  return {
    tables: state.tables,
    profile: state.profile,
    nameAutoGeneration: state.model.nameAutoGeneration,
    def_collation: state.model.def_collation,
    customDataTypes: state.model.customDataTypes,
    type: state.model.type,
    relations: state.relations,
    localization: state.localization,
    otherObjectsArray: getReducedOtherObjectsList(state).otherObjectArray,
    tableEmbeddableWithColsArray:
      getEmbeddableWithColsList(state).tableEmbeddableWithColsArray
  };
}

function mapDispatchToProps(dispatch) {
  return {
    ...bindActionCreators(
      {
        fetchColumn,
        addColumnToKey,
        finishTransaction,
        startTransaction,
        updateAutoGeneratedNamesForKey,
        setDataTypeComplex
      },
      dispatch
    ),
    dispatch
  };
}

export default withRouter(
  connect(mapStateToProps, mapDispatchToProps)(NewColumn)
);
