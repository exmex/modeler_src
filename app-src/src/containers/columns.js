import { ModelTypes, ObjectType } from "../enums/enums";
import React, { Component } from "react";
import {
  addColumnToKey,
  deleteColumnFromAllObjects,
  getAutoGeneratedIndexes,
  getAutoGeneratedKeys,
  getAutoGeneratedNamesForKey,
  getAutoGeneratedRelations,
  getDefaultDataType,
  removeColumnFromKey,
  setDataTypeComplex,
  updateAutoGeneratedNamesForKey,
  updateColumnProperty,
  updateKeyIndexNames,
  updateRelationNames
} from "../actions/tables";
import {
  finishTransaction,
  getCurrentHistoryTransaction,
  startTransaction
} from "../actions/undoredo";

import ColumnsGraphQl from "../platforms/graphql/columns_graphql";
import ColumnsJsonSchema from "../platforms/jsonschema/columns_jsonschema";
import ColumnsLogical from "../platforms/logical/columns_logical";
import ColumnsMSSQL from "../platforms/mssql/columns_mssql";
import ColumnsMongoDb from "../platforms/mongodb/columns_mongodb";
import ColumnsMongoose from "../platforms/mongoose/columns_mongoose";
import ColumnsMySQLFamily from "../platforms/mysql_family/columns_mysql_family";
import ColumnsPG from "../platforms/pg/columns_pg";
import ColumnsSQLite from "../platforms/sqlite/columns_sqlite";
import ColumnsSequelize from "../platforms/sequelize/columns_sequelize";
import { CompositeDependencies } from "../platforms/pg/composite_dependencies";
import Helpers from "../helpers/helpers";
import JsonHelpers from "../platforms/json/helpers_json";
import JsonSchemaHelpers from "../platforms/jsonschema/helpers_jsonschema";
import ModalTextEditor from "../containers/modals/modal_text_editor";
import MongoDbHelpers from "../platforms/mongodb/helpers_mongodb";
import MongooseHelpers from "../platforms/mongoose/helpers_mongoose";
import { OtherObjectTypes } from "common";
import { UndoRedoDef } from "../helpers/history/undo_redo_transaction_defs";
import _ from "lodash";
import arrayMove from "array-move";
import { bindActionCreators } from "redux";
import { connect } from "react-redux";
import { existsTableCycle } from "../helpers/cycle_detection";
import { getEmbeddableWithColsList } from "../selectors/selector_tables";
import { getHistoryContext } from "../helpers/history/history";
import { isPerseid } from "../helpers/features/features";
import { toggleTextEditorModal } from "../actions/ui";
import { v4 as uuidv4 } from "uuid";
import { withRouter } from "react-router-dom";

class Columns extends Component {
  async handleTextChange(target, propName, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY
    );
    try {
      await this.props.updateColumnProperty(
        this.props.passedTableId,
        target,
        value,
        propName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleTextChangePlatform(property, columnid, platform, event) {
    const column = this.props.tables[this.props.match.params.id].cols.find(
      (col) => col.id === columnid
    );
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_PLATFORM
    );
    try {
      await this.props.updateColumnProperty(
        this.props.match.params.id,
        columnid,
        { ...column[platform], [property]: value },
        platform
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleChange(propertyName, e) {
    const value = e.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_OTHER_OBJECT_PROPERTY
    );
    try {
      await this.props.updateOtherObjectProperty(
        this.props.match.params.oid,
        value,
        propertyName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }
  async handleSelectChange(target, propName, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY
    );
    try {
      await this.props.updateColumnProperty(
        this.props.passedTableId,
        target,
        value,
        propName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleCheckboxChange(target, propName, event) {
    const checked = event.target.checked;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_BOOLEAN
    );
    try {
      await this.props.updateColumnProperty(
        this.props.passedTableId,
        target,
        checked,
        propName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleCheckboxChangePlatform(property, columnid, platform, event) {
    const checked = event.target.checked;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_BOOLEAN_PLATFORM
    );
    try {
      const column = this.props.tables[this.props.match.params.id].cols.find(
        (col) => col.id === columnid
      );
      await this.props.updateColumnProperty(
        this.props.match.params.id,
        columnid,
        { ...column[platform], [property]: checked },
        platform
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleChangeDatatype(col_id, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_DATATYPE
    );
    try {
      await this.props.updateColumnProperty(
        this.props.passedTableId,
        col_id,
        value,
        "datatype"
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleChangeDatatypeMongo(col_id, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_DATATYPE
    );
    try {
      await this.props.setDataTypeComplex(
        getHistoryContext(this.props.history, this.props.match),
        col_id,
        this.props.passedTableId,
        value,
        MongoDbHelpers.getMongoDBHierarchyType()
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async deleteColComplex(col_id) {
    const historyContext = getHistoryContext(
      this.props.history,
      this.props.match
    );
    const value = getDefaultDataType(this.props.type, false);
    await this.props.startTransaction(
      historyContext,
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_DATATYPE
    );
    try {
      await this.props.setDataTypeComplex(
        historyContext,
        col_id,
        this.props.passedTableId,
        value,
        ""
      );
      await this.deleteCol(this.props.passedTableId, col_id, historyContext);
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleChangeDatatypeMongoose(col_id, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__UPDATE_COLUMN_PROPERTY_DATATYPE
    );
    try {
      await this.props.setDataTypeComplex(
        getHistoryContext(this.props.history, this.props.match),
        col_id,
        this.props.passedTableId,
        value,
        MongooseHelpers.getMongooseHierarchyType()
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handlePkCheck(col_id, event) {
    const checked = event.target.checked;

    const historyContext = getHistoryContext(
      this.props.history,
      this.props.match
    );
    await this.props.startTransaction(
      historyContext,
      UndoRedoDef.COLUMNS__PK_TOGGLE
    );
    try {
      var clnActvTbl = this.props.tables[this.props.passedTableId];
      var tablePk = _.find(clnActvTbl.keys, ["isPk", true]);
      const autoGeneratedNames = getAutoGeneratedNamesForKey({
        settings: {
          type: this.props.type,
          nameAutoGeneration: this.props.nameAutoGeneration
        },
        tables: this.props.tables,
        table: clnActvTbl,
        key: tablePk,
        relations: this.props.relations
      });
      if (checked) {
        await this.props.addColumnToKey(
          this.props.match.params.id,
          col_id,
          this.props.passedTableId,
          tablePk.id
        );

        getCurrentHistoryTransaction().addResizeRequest({
          domToModel: true,
          operation: "addColumnToKey"
        });
      } else {
        await this.props.removeColumnFromKey(
          historyContext,
          col_id,
          this.props.passedTableId,
          tablePk.id
        );

        getCurrentHistoryTransaction().addResizeRequest({
          domToModel: true,
          operation: "removeColumnFromKey"
        });
      }

      await this.props.updateAutoGeneratedNamesForKey(autoGeneratedNames);
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleUniqueCheck(col_id, event) {
    const checked = event.target.checked;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__COLUMN_PROPERTY_UNIQUE
    );
    try {
      if (checked === false) {
        await this.props.updateColumnProperty(
          this.props.passedTableId,
          col_id,
          "",
          "uniqueName"
        );
      }

      await this.props.updateColumnProperty(
        this.props.passedTableId,
        col_id,
        checked,
        "unique"
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleChangeUniqueName(target, propName, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.COLUMNS__COLUMN_PROPERTY_UNIQUE_2
    );
    try {
      await this.props.updateColumnProperty(
        this.props.passedTableId,
        target,
        value,
        propName
      );

      if (value !== undefined && value !== "") {
        await this.props.updateColumnProperty(
          this.props.passedTableId,
          target,
          true,
          "unique"
        );
      }
    } finally {
      await this.props.finishTransaction();
    }
  }

  async deleteCol(tableId, colId, historyContext) {
    const settings = {
      type: this.props.type,
      nameAutoGeneration: this.props.nameAutoGeneration
    };
    const autoGeneratedKeys = getAutoGeneratedKeys(
      settings,
      this.props.tables,
      this.props.tables[tableId]
    );

    const autoGeneratedIndexes = getAutoGeneratedIndexes(
      settings,
      this.props.tables,
      this.props.tables[tableId]
    );

    const childTables = _.reduce(
      this.props.tables[tableId].relations,
      (result, relId) => ({
        ...result,
        [this.props.relations[relId].child]:
          this.props.tables[this.props.relations[relId].child]
      }),
      {}
    );

    const autoGeneratedRelations = getAutoGeneratedRelations(
      settings,
      this.props.relations,
      childTables,
      this.props.tables[tableId][colId]
    );

    await this.props.deleteColumnFromAllObjects(historyContext, tableId, colId);

    if (autoGeneratedKeys.length > 0 || autoGeneratedIndexes.length > 0) {
      await this.props.updateKeyIndexNames(
        tableId,
        autoGeneratedKeys,
        autoGeneratedIndexes
      );
    }

    if (autoGeneratedRelations.length > 0) {
      await this.props.updateRelationNames(autoGeneratedRelations);
    }
  }

  async deleteColTransaction(tableId, colId) {
    const historyContext = getHistoryContext(
      this.props.history,
      this.props.match
    );
    await this.props.startTransaction(
      historyContext,
      UndoRedoDef.COLUMNS__DELETE_COL
    );
    try {
      await this.deleteCol(tableId, colId, historyContext);
    } finally {
      await this.props.finishTransaction();
    }
  }

  getJSONSchemaEmbeddableCaption(table) {
    return !JsonSchemaHelpers.isRootOrDef(table)
      ? table.name
      : table.name + " (" + table.objectType + ")";
  }

  getCommonEmbeddableCaption(table) {
    return table.name + " (" + this.props.localization.L_TABLE_EMBEDDABLE + ")";
  }

  renderEmbeddable(tableId) {
    let tableToRemoveFromList = tableId ? tableId : this.props.match.params.id;
    var embeddableTables = _.filter(this.props.tables, ["embeddable", true]);
    embeddableTables = _.reject(embeddableTables, [
      "id",
      tableToRemoveFromList
    ]);

    if (isPerseid(this.props.profile)) {
      embeddableTables = _.filter(embeddableTables, function (o) {
        return JsonSchemaHelpers.isRootOrDef(o);
      });
    }

    return _.map(embeddableTables, (tx) => {
      if (
        existsTableCycle(this.props.tables, tx, tableToRemoveFromList) === false
      ) {
        let optionValueName =
          this.props.type === ObjectType.JSONSCHEMA
            ? this.getJSONSchemaEmbeddableCaption(tx)
            : this.getCommonEmbeddableCaption(tx);

        return (
          <option key={tx.id} value={tx.id}>
            {optionValueName}
          </option>
        );
      }
    });
  }

  renderDomains() {
    return _.filter(
      this.props.otherObjects,
      (otherObject) => otherObject.type === "Domain"
    ).map((otherObject) => (
      <option
        key={"c_" + otherObject.id}
        value={otherObject.id}
        className="im-datatypes-tables"
      >
        {otherObject.name + " (domain)"}
      </option>
    ));
  }

  renderEnums() {
    return _.filter(
      this.props.otherObjects,
      (otherObject) => otherObject.type === "Enum"
    ).map((otherObject) => (
      <option
        key={"c_" + otherObject.id}
        value={otherObject.id}
        className="im-datatypes-tables"
      >
        {otherObject.name + " (enum)"}
      </option>
    ));
  }

  renderTypes() {
    return _.filter(
      this.props.otherObjects,
      (otherObject) => otherObject.type === "TypeOther"
    ).map((otherObject) => (
      <option
        key={"c_" + otherObject.id}
        value={otherObject.id}
        className="im-datatypes-tables"
      >
        {otherObject.name + " (type)"}
      </option>
    ));
  }

  renderUserDefinedTypes() {
    return _.filter(
      this.props.otherObjects,
      (otherObject) => otherObject.type === OtherObjectTypes.UserDefinedType
    ).map((otherObject) => (
      <option
        key={"c_" + otherObject.id}
        value={otherObject.id}
        className="im-datatypes-tables"
      >
        {otherObject.name + " (type)"}
      </option>
    ));
  }

  renderComposites() {
    const composites = Object.keys(this.props.tables)
      .map((key) => this.props.tables[key])
      .filter((table) => table.objectType === "composite");
    const notCycledComposites = new CompositeDependencies().notCycledComposites(
      composites,
      this.props.tables[this.props.match.params.id].objectType === "composite"
        ? this.props.tables[this.props.match.params.id]
        : null
    );
    return notCycledComposites.map((composite) => (
      <option
        key={"c_" + composite.name}
        value={composite.id}
        className="im-datatypes-tables"
      >
        {composite.name + " (composite)"}
      </option>
    ));
  }

  renderEmbeddableForSchemas() {
    return _.map(this.props.tableEmbeddableWithColsArray, (table) => {
      if (
        existsTableCycle(
          this.props.tables,
          table,
          this.props.match.params.id
        ) === false
      ) {
        return (
          <option
            key={uuidv4()}
            value={table.id}
            className="im-datatypes-tables"
          >
            {table.name +
              " (" +
              this.props.localization.L_TABLE_EMBEDDABLE +
              ")"}
          </option>
        );
      }
    });
  }

  renderSchemas() {
    var embeddableTables = _.filter(this.props.tables, ["embeddable", false]);
    embeddableTables = _.sortBy(embeddableTables, ["name"]);
    embeddableTables = _.reject(embeddableTables, [
      "id",
      this.props.match.params.id
    ]);
    return _.map(embeddableTables, (table) => {
      if (
        existsTableCycle(
          this.props.tables,
          table,
          this.props.match.params.id
        ) === false
      ) {
        return (
          <option
            key={uuidv4()}
            value={table.id}
            className="im-datatypes-tables"
          >
            {table.name + " (" + this.props.localization.L_TABLE + ")"}
          </option>
        );
      }
    });
  }

  renderOtherObjects(objectType, objectTypeName) {
    var otherObjectsList = _.filter(this.props.otherObjects, [
      "type",
      objectType
    ]);
    otherObjectsList = _.sortBy(otherObjectsList, ["name"]);
    return _.map(otherObjectsList, (otherObjectItem) => {
      return (
        <option
          key={uuidv4()}
          value={otherObjectItem.id}
          className="im-datatypes-tables"
        >
          {otherObjectItem.name + " (" + objectTypeName + ")"}
        </option>
      );
    });
  }

  renderDataTypesJson(fn, colDatatype) {
    return (
      <select value={colDatatype} onChange={fn}>
        {JsonHelpers.makeDatatypesJson()}
        {this.renderEmbeddable(this.props.passedTableId)}
        {this.renderCustomDatatypes()}
      </select>
    );
  }

  renderCustomDatatypes() {
    return _.map(this.props.customDataTypes, (customDataType) => {
      return (
        <option
          key={"c_" + customDataType}
          value={customDataType}
          className="im-datatypes-tables"
        >
          {customDataType}
        </option>
      );
    });
  }

  onSortEnd = ({ oldIndex, newIndex }) => {
    this.setState(({ items }) => ({
      items: arrayMove(items, oldIndex, newIndex)
    }));
  };

  openInLargeWindow(col, propertyName, header) {
    this.props.toggleTextEditorModal(
      <ModalTextEditor
        textEditorId={uuidv4()}
        onChange={this.handleTextChange.bind(this, col.id, propertyName)}
        modalHeader={_.upperFirst(header)}
        text={Helpers.gv(col[propertyName])}
      />
    );
  }

  renderColumnsByPlatform(platform) {
    switch (platform) {
      case "MONGODB":
        return (
          <ColumnsMongoDb
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            deleteColComplex={this.deleteColComplex.bind(this)}
            handleChangeDatatypeMongo={this.handleChangeDatatypeMongo.bind(
              this
            )}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderSchemas={this.renderSchemas.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );

      case "MONGOOSE":
        return (
          <ColumnsMongoose
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            deleteColComplex={this.deleteColComplex.bind(this)}
            handleChangeDatatypeMongoose={this.handleChangeDatatypeMongoose.bind(
              this
            )}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderEnums={this.renderEnums.bind(this)}
            renderEmbeddableForSchemas={this.renderEmbeddableForSchemas.bind(
              this
            )}
            renderSchemas={this.renderSchemas.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case "SEQUELIZE":
        return (
          <ColumnsSequelize
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case ModelTypes.MYSQL:
      case ModelTypes.MARIADB:
        return (
          <ColumnsMySQLFamily
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case "SQLITE":
        return (
          <ColumnsSQLite
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            handleCheckboxChangePlatform={this.handleCheckboxChangePlatform.bind(
              this
            )}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case "PG":
        return (
          <ColumnsPG
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderDomains={this.renderDomains.bind(this)}
            renderEnums={this.renderEnums.bind(this)}
            renderTypes={this.renderTypes.bind(this)}
            renderComposites={this.renderComposites.bind(this)}
            handleTextChangePlatform={this.handleTextChangePlatform.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case "MSSQL":
        return (
          <ColumnsMSSQL
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderUserDefinedTypes={this.renderUserDefinedTypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            handleTextChangePlatform={this.handleTextChangePlatform.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case "GRAPHQL":
        return (
          <ColumnsGraphQl
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            renderSchemas={this.renderSchemas.bind(this)}
            renderOtherObjects={this.renderOtherObjects.bind(this)}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case "LOGICAL":
        return (
          <ColumnsLogical
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            handleCheckboxChangePlatform={this.handleCheckboxChangePlatform.bind(
              this
            )}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      case ModelTypes.JSONSCHEMA:
      case ModelTypes.OPENAPI:
      case ModelTypes.FULLJSON:
        return (
          <ColumnsJsonSchema
            showOnlyActiveColumn={this.props.showOnlyActiveColumn}
            passedTableId={this.props.passedTableId}
            deleteCol={this.deleteColTransaction.bind(this)}
            handleChangeDatatype={this.handleChangeDatatype.bind(this)}
            handleChangeUniqueName={this.handleChangeUniqueName.bind(this)}
            handleCheckboxChange={this.handleCheckboxChange.bind(this)}
            handlePkCheck={this.handlePkCheck.bind(this)}
            handleSelectChange={this.handleSelectChange.bind(this)}
            handleTextChange={this.handleTextChange.bind(this)}
            handleUniqueCheck={this.handleUniqueCheck.bind(this)}
            renderCustomDatatypes={this.renderCustomDatatypes.bind(this)}
            renderDataTypesJson={this.renderDataTypesJson.bind(this)}
            renderEmbeddable={this.renderEmbeddable.bind(this)}
            handleCheckboxChangePlatform={this.handleCheckboxChangePlatform.bind(
              this
            )}
            openInLargeWindow={this.openInLargeWindow.bind(this)}
          />
        );
      default:
        return <></>;
    }
  }

  render() {
    return (
      <React.Fragment>
        {this.renderColumnsByPlatform(this.props.type)}
      </React.Fragment>
    );
  }
}

function mapStateToProps(state) {
  return {
    tables: state.tables,
    profile: state.profile,
    relations: state.relations,
    otherObjects: state.otherObjects,
    customDataTypes: state.model.customDataTypes,
    type: state.model.type,
    nameAutoGeneration: state.model.nameAutoGeneration,
    localization: state.localization,
    tableEmbeddableWithColsArray:
      getEmbeddableWithColsList(state).tableEmbeddableWithColsArray
  };
}

function mapDispatchToProps(dispatch) {
  return {
    ...bindActionCreators(
      {
        updateColumnProperty,
        addColumnToKey,
        removeColumnFromKey,
        deleteColumnFromAllObjects,
        finishTransaction,
        startTransaction,
        updateAutoGeneratedNamesForKey,
        updateKeyIndexNames,
        updateRelationNames,
        toggleTextEditorModal,
        setDataTypeComplex
      },
      dispatch
    ),
    dispatch
  };
}

export default withRouter(
  connect(mapStateToProps, mapDispatchToProps)(Columns)
);
