import {
  BracketType,
  ScopeType
} from "../../../generator/model-to-sql-model/sql_model_builder";
import {
  INCLUDE_GENERATED_NAMES_ALWAYS,
  INCLUDE_GENERATED_NAMES_CUSTOM_NAMES_ONLY
} from "../../../generator/sql-model-to-lines/model_to_lines";

import { ObjectToSQLModel } from "../../../generator/model-to-sql-model/object_to_sql_model";
import PGHelpers from "../helpers_pg";

const KEYWORDS = {
  CREATE: `CREATE`,
  TYPE: `TYPE`,
  AS: `AS`,
  GENERATED: `GENERATED`,
  ALWAYS: `ALWAYS`,
  IDENTITY: `IDENTITY`,
  BY: `BY`,
  DEFAULT: `DEFAULT`,
  TABLE: `TABLE`,
  TABLESPACE: `TABLESPACE`,
  PARTITION: `PARTITION`,
  INHERITS: `INHERITS`,
  USING: `USING`,
  ON: `ON`,
  INDEX: `INDEX`,
  UNIQUE: `UNIQUE`,
  NULLS: `NULLS`,
  LAST: `LAST`,
  DESC: `DESC`,
  COLLATE: `COLLATE`,
  WITH: `WITH`,
  PRIMARY: `PRIMARY`,
  KEY: `KEY`,
  CONSTRAINT: `CONSTRAINT`,
  COLUMN: `COLUMN`,
  SECURITY: `SECURITY`,
  LEVEL: `LEVEL`,
  ROW: `ROW`,
  ENABLE: `ENABLE`,
  ALTER: `ALTER`,
  COMMENT: `COMMENT`,
  IS: `IS`,
  NOT: `NOT`,
  NULL: `NULL`,
  GIST: `GIST`,
  HASH: `HASH`
};

export class IndexToSQLModelPG extends ObjectToSQLModel {
  constructor(
    sqlModelBuilder,
    finder,
    generatorOptions,
    table,
    index,
    tableNameGenerator
  ) {
    super(sqlModelBuilder, finder, generatorOptions, table);
    this.index = index;
    this.tableNameGenerator = tableNameGenerator;
  }

  getTable() {
    return this.getModelObject();
  }

  getIndex() {
    return this.index;
  }

  updateIndexExpression(expression) {
    const regex = new RegExp(
      `[oO][nN]\\s+("${this.getTable().name}")|${this.getTable().name}\\s+`
    );
    return expression.replace(
      regex,
      `${this.tableNameGenerator.generate(this.getTable())} `
    );
  }

  refIndexColumnsBlock() {
    return this.sb.list(
      ...this.getIndex()
        .cols.filter(
          (indexColumn) =>
            !!this.getTable().cols.find(
              (tableColumn) => indexColumn.colid === tableColumn.id
            )
        )
        .map((ref) => {
          const indexCol = this.getTable().cols.find(
            (col) => ref.colid === col.id
          );
          return this.sb.block(
            ref.pg?.expression
              ? this.sb.code(this.updateIndexExpression(ref.pg.expression))
              : this.sb.identifier(indexCol.name, false, ScopeType.SUBOBJECT),
            ...this.parameter([KEYWORDS.COLLATE], ref.pg?.collate, true),
            ref.pg?.desc ? this.sb.keyword(KEYWORDS.DESC) : undefined,
            ...(ref.pg?.nullsLast &&
            this.getIndex().algorithm?.toUpperCase() !== KEYWORDS.GIST &&
            this.getIndex().algorithm?.toUpperCase() !== KEYWORDS.HASH
              ? [
                  this.sb.keyword(KEYWORDS.NULLS),
                  this.sb.keyword(KEYWORDS.LAST)
                ]
              : [])
          );
        })
    );
  }

  isIndexNameAutoGenerated() {
    return (
      PGHelpers.makeIndexName(
        this.getIndex(),
        this.getTable(),
        this.finder.tables
      ) !== this.getIndex().name
    );
  }

  shouldAddIndexName() {
    switch (this.generatorOptions.includeGeneratedNames) {
      case INCLUDE_GENERATED_NAMES_ALWAYS:
        return !!this.getIndex().name;
      case INCLUDE_GENERATED_NAMES_CUSTOM_NAMES_ONLY:
        return this.isIndexNameAutoGenerated();
      default:
        return false;
    }
  }

  indexName() {
    return this.shouldAddIndexName()
      ? [this.sb.identifier(this.getIndex().name, false, ScopeType.SUBOBJECT)]
      : [];
  }

  indexStatement() {
    return [
      this.sb.statement(
        this.sb.keyword(KEYWORDS.CREATE),
        this.getIndex().unique ? this.sb.keyword(KEYWORDS.UNIQUE) : undefined,
        this.sb.keyword(KEYWORDS.INDEX),
        ...this.indexName(),
        this.sb.keyword(KEYWORDS.ON),
        this.sb.qualifiedIdentifier(this.getTable()),
        this.getIndex().algorithm
          ? this.sb.block(
              this.sb.keyword(KEYWORDS.USING),
              this.sb.literal(this.getIndex().algorithm)
            )
          : undefined,
        this.sb.brackets(this.refIndexColumnsBlock(), true, BracketType.ROUND),
        ...this.storageParams(this.getIndex().pg?.storageParameters),
        ...this.parameter(
          [KEYWORDS.TABLESPACE],
          this.getIndex().pg?.tablespace,
          false
        ),
        this.sb.statementDelimiter(false)
      ),
      ...this.indexCommentStatement()
    ];
  }

  storageParams(storageParameters) {
    return storageParameters && storageParameters !== ""
      ? [
          this.sb.keyword(KEYWORDS.WITH),
          this.sb.brackets(
            //
            this.sb.literal(storageParameters),
            true,
            BracketType.ROUND
          )
        ]
      : [];
  }

  commentStatement(type, qualifiedIdentifier, comment) {
    return !!comment
      ? this.sb.statement(
          this.sb.keyword(KEYWORDS.COMMENT),
          this.sb.keyword(KEYWORDS.ON),
          this.sb.keyword(type),
          qualifiedIdentifier,
          this.sb.keyword(KEYWORDS.IS),
          this.sb.quotedLiteral(comment),
          this.sb.statementDelimiter(false)
        )
      : undefined;
  }

  indexCommentStatement() {
    return [
      this.commentStatement(
        KEYWORDS.INDEX,
        this.qualifiedIdentifierOnlyInner(this.getTable(), this.index),
        this.getIndex().pg.desc
      )
    ];
  }

  qualifiedIdentifierOnlyInner(obj, innerObj) {
    return this.sb.qualifiedIdentifierOnlyInner(obj, innerObj);
  }

  objectStatements() {
    const s = this.getIndex().pg?.expression
      ? [
          this.sb.statement(
            this.sb.code(
              this.updateIndexExpression(this.getIndex().pg.expression)
            )
          )
        ]
      : this.indexStatement();
    return s;
  }
}
