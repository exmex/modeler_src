/** Source: https://learn.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver16 */
const KEYWORDS = [
  "add",
  "external",
  "procedure",
  "all",
  "fetch",
  "public",
  "alter",
  "file",
  "raiserror",
  "and",
  "fillfactor",
  "read",
  "any",
  "for",
  "readtext",
  "as",
  "foreign",
  "reconfigure",
  "asc",
  "freetext",
  "references",
  "authorization",
  "freetexttable",
  "replication",
  "backup",
  "from",
  "restore",
  "begin",
  "full",
  "restrict",
  "between",
  "function",
  "return",
  "break",
  "goto",
  "revert",
  "browse",
  "grant",
  "revoke",
  "bulk",
  "group",
  "right",
  "by",
  "having",
  "rollback",
  "cascade",
  "holdlock",
  "rowcount",
  "case",
  "identity",
  "rowguidcol",
  "check",
  "identity_insert",
  "rule",
  "checkpoint",
  "identitycol",
  "save",
  "close",
  "if",
  "schema",
  "clustered",
  "in",
  "securityaudit",
  "coalesce",
  "index",
  "select",
  "collate",
  "inner",
  "semantickeyphrasetable",
  "column",
  "insert",
  "semanticsimilaritydetailstable",
  "commit",
  "intersect",
  "semanticsimilaritytable",
  "compute",
  "into",
  "session_user",
  "constraint",
  "is",
  "set",
  "contains",
  "join",
  "setuser",
  "containstable",
  "key",
  "shutdown",
  "continue",
  "kill",
  "some",
  "convert",
  "left",
  "statistics",
  "create",
  "like",
  "system_user",
  "cross",
  "lineno",
  "table",
  "current",
  "load",
  "tablesample",
  "current_date",
  "merge",
  "textsize",
  "current_time",
  "national",
  "then",
  "current_timestamp",
  "nocheck",
  "to",
  "current_user",
  "nonclustered",
  "top",
  "cursor",
  "not",
  "tran",
  "database",
  "null",
  "transaction",
  "dbcc",
  "nullif",
  "trigger",
  "deallocate",
  "of",
  "truncate",
  "declare",
  "off",
  "try_convert",
  "default",
  "offsets",
  "tsequal",
  "delete",
  "on",
  "union",
  "deny",
  "open",
  "unique",
  "desc",
  "opendatasource",
  "unpivot",
  "disk",
  "openquery",
  "update",
  "distinct",
  "openrowset",
  "updatetext",
  "distributed",
  "openxml",
  "use",
  "double",
  "option",
  "user",
  "drop",
  "or",
  "values",
  "dump",
  "order",
  "varying",
  "else",
  "outer",
  "view",
  "end",
  "over",
  "waitfor",
  "errlvl",
  "percent",
  "when",
  "escape",
  "pivot",
  "where",
  "except",
  "plan",
  "while",
  "exec",
  "precision",
  "with",
  "execute",
  "primary",
  "within group",
  "exists",
  "print",
  "writetext",
  "exit",
  "proc",
  "absolute",
  "exec",
  "overlaps",
  "action",
  "execute",
  "pad",
  "ada",
  "exists",
  "partial",
  "add",
  "external",
  "pascal",
  "all",
  "extract",
  "position",
  "allocate",
  "false",
  "precision",
  "alter",
  "fetch",
  "prepare",
  "and",
  "first",
  "preserve",
  "any",
  "float",
  "primary",
  "are",
  "for",
  "prior",
  "as",
  "foreign",
  "privileges",
  "asc",
  "fortran",
  "procedure",
  "assertion",
  "found",
  "public",
  "at",
  "from",
  "read",
  "authorization",
  "full",
  "real",
  "avg",
  "get",
  "references",
  "begin",
  "global",
  "relative",
  "between",
  "go",
  "restrict",
  "bit",
  "goto",
  "revoke",
  "bit_length",
  "grant",
  "right",
  "both",
  "group",
  "rollback",
  "by",
  "having",
  "rows",
  "cascade",
  "hour",
  "schema",
  "cascaded",
  "identity",
  "scroll",
  "case",
  "immediate",
  "second",
  "cast",
  "in",
  "section",
  "catalog",
  "include",
  "select",
  "char",
  "index",
  "session",
  "char_length",
  "indicator",
  "session_user",
  "character",
  "initially",
  "set",
  "character_length",
  "inner",
  "size",
  "check",
  "input",
  "smallint",
  "close",
  "insensitive",
  "some",
  "coalesce",
  "insert",
  "space",
  "collate",
  "int",
  "sql",
  "collation",
  "integer",
  "sqlca",
  "column",
  "intersect",
  "sqlcode",
  "commit",
  "interval",
  "sqlerror",
  "connect",
  "into",
  "sqlstate",
  "connection",
  "is",
  "sqlwarning",
  "constraint",
  "isolation",
  "substring",
  "constraints",
  "join",
  "sum",
  "continue",
  "key",
  "system_user",
  "convert",
  "language",
  "table",
  "corresponding",
  "last",
  "temporary",
  "count",
  "leading",
  "then",
  "create",
  "left",
  "time",
  "cross",
  "level",
  "timestamp",
  "current",
  "like",
  "timezone_hour",
  "current_date",
  "local",
  "timezone_minute",
  "current_time",
  "lower",
  "to",
  "current_timestamp",
  "match",
  "trailing",
  "current_user",
  "max",
  "transaction",
  "cursor",
  "min",
  "translate",
  "date",
  "minute",
  "translation",
  "day",
  "module",
  "trim",
  "deallocate",
  "month",
  "true",
  "dec",
  "names",
  "union",
  "decimal",
  "national",
  "unique",
  "declare",
  "natural",
  "unknown",
  "default",
  "nchar",
  "update",
  "deferrable",
  "next",
  "upper",
  "deferred",
  "no",
  "usage",
  "delete",
  "none",
  "user",
  "desc",
  "not",
  "using",
  "describe",
  "null",
  "value",
  "descriptor",
  "nullif",
  "values",
  "diagnostics",
  "numeric",
  "varchar",
  "disconnect",
  "octet_length",
  "varying",
  "distinct",
  "of",
  "view",
  "domain",
  "on",
  "when",
  "double",
  "only",
  "whenever",
  "drop",
  "open",
  "where",
  "else",
  "option",
  "with",
  "end",
  "or",
  "work",
  "end-exec",
  "order",
  "write",
  "escape",
  "outer",
  "year",
  "except",
  "output",
  "zone",
  "exception",
  "absolute",
  "host",
  "relative",
  "action",
  "hour",
  "release",
  "admin",
  "ignore",
  "result",
  "after",
  "immediate",
  "returns",
  "aggregate",
  "indicator",
  "role",
  "alias",
  "initialize",
  "rollup",
  "allocate",
  "initially",
  "routine",
  "are",
  "inout",
  "row",
  "array",
  "input",
  "rows",
  "asensitive",
  "int",
  "savepoint",
  "assertion",
  "integer",
  "scroll",
  "asymmetric",
  "intersection",
  "scope",
  "at",
  "interval",
  "search",
  "atomic",
  "isolation",
  "second",
  "before",
  "iterate",
  "section",
  "binary",
  "language",
  "sensitive",
  "bit",
  "large",
  "sequence",
  "blob",
  "last",
  "session",
  "boolean",
  "lateral",
  "sets",
  "both",
  "leading",
  "similar",
  "breadth",
  "less",
  "size",
  "call",
  "level",
  "smallint",
  "called",
  "like_regex",
  "space",
  "cardinality",
  "limit",
  "specific",
  "cascaded",
  "ln",
  "specifictype",
  "cast",
  "local",
  "sql",
  "catalog",
  "localtime",
  "sqlexception",
  "char",
  "localtimestamp",
  "sqlstate",
  "character",
  "locator",
  "sqlwarning",
  "class",
  "map",
  "start",
  "clob",
  "match",
  "state",
  "collation",
  "member",
  "statement",
  "collect",
  "method",
  "static",
  "completion",
  "minute",
  "stddev_pop",
  "condition",
  "mod",
  "stddev_samp",
  "connect",
  "modifies",
  "structure",
  "connection",
  "modify",
  "submultiset",
  "constraints",
  "module",
  "substring_regex",
  "constructor",
  "month",
  "symmetric",
  "corr",
  "multiset",
  "system",
  "corresponding",
  "names",
  "temporary",
  "covar_pop",
  "natural",
  "terminate",
  "covar_samp",
  "nchar",
  "than",
  "cube",
  "nclob",
  "time",
  "cume_dist",
  "new",
  "timestamp",
  "current_catalog",
  "next",
  "timezone_hour",
  "current_default_transform_group",
  "no",
  "timezone_minute",
  "current_path",
  "none",
  "trailing",
  "current_role",
  "normalize",
  "translate_regex",
  "current_schema",
  "numeric",
  "translation",
  "current_transform_group_for_type",
  "object",
  "treat",
  "cycle",
  "occurrences_regex",
  "true",
  "data",
  "old",
  "uescape",
  "date",
  "only",
  "under",
  "day",
  "operation",
  "unknown",
  "dec",
  "ordinality",
  "unnest",
  "decimal",
  "out",
  "usage",
  "deferrable",
  "overlay",
  "using",
  "deferred",
  "output",
  "value",
  "depth",
  "pad",
  "var_pop",
  "deref",
  "parameter",
  "var_samp",
  "describe",
  "parameters",
  "varchar",
  "descriptor",
  "partial",
  "variable",
  "destroy",
  "partition",
  "whenever",
  "destructor",
  "path",
  "width_bucket",
  "deterministic",
  "postfix",
  "without",
  "dictionary",
  "prefix",
  "window",
  "diagnostics",
  "preorder",
  "within",
  "disconnect",
  "prepare",
  "work",
  "domain",
  "percent_rank",
  "write",
  "dynamic",
  "percentile_cont",
  "xmlagg",
  "each",
  "percentile_disc",
  "xmlattributes",
  "element",
  "position_regex",
  "xmlbinary",
  "end-exec",
  "preserve",
  "xmlcast",
  "equals",
  "prior",
  "xmlcomment",
  "every",
  "privileges",
  "xmlconcat",
  "exception",
  "range",
  "xmldocument",
  "false",
  "reads",
  "xmlelement",
  "filter",
  "real",
  "xmlexists",
  "first",
  "recursive",
  "xmlforest",
  "float",
  "ref",
  "xmliterate",
  "found",
  "referencing",
  "xmlnamespaces",
  "free",
  "regr_avgx",
  "xmlparse",
  "fulltexttable",
  "regr_avgy",
  "xmlpi",
  "fusion",
  "regr_count",
  "xmlquery",
  "general",
  "regr_intercept",
  "xmlserialize",
  "get",
  "regr_r2",
  "xmltable",
  "global",
  "regr_slope",
  "xmltext",
  "go",
  "regr_sxx",
  "xmlvalidate",
  "grouping",
  "regr_sxy",
  "year",
  "hold",
  "regr_syy",
  "zone"
];

export class MSSQLQuotation {
  leftQuote() {
    return "[";
  }

  rightQuote() {
    return "]";
  }

  public generateName(includeSchema: boolean, schema: string, name: string) {
    return `${
      includeSchema === true ? `${this.quoteIdentifier(schema, false)}.` : ``
    }${this.quoteIdentifier(name, false)}`;
  }

  quoteIdentifier(identifier: string, forceQuotation: boolean) {
    if (
      forceQuotation === true ||
      KEYWORDS.filter((keyword) => keyword === identifier.toLowerCase())
        .length > 0
    ) {
      return `${this.leftQuote()}${identifier}${this.rightQuote()}`;
    }
    const plainIdentifier =
      identifier.match(/^([^0-9]|[^\x20-\x7F]|[\w])+$/g) &&
      identifier.match(/^[^0-9][\w]*$/g);

    return plainIdentifier
      ? this.containsUpperChar(identifier)
        ? `${this.leftQuote()}${identifier}${this.rightQuote()}`
        : identifier
      : `${this.leftQuote()}${identifier}${this.rightQuote()}`;
  }

  isUpper(character: string) {
    return (
      character !== character.toLowerCase() &&
      character === character.toUpperCase()
    );
  }

  containsUpperChar(string: string) {
    for (let i = 0; i < string.length; i++) {
      if (this.isUpper(string[i])) {
        return true;
      }
    }
    return false;
  }

  quoteComment(comment: string) {
    const lineBreakedIndex = comment && comment.indexOf(`\n`);
    return lineBreakedIndex && lineBreakedIndex > 0
      ? `/* ${comment} */`
      : `/* ${comment} */`;
  }

  quoteLiteral(literal: string) {
    return `'${literal ? literal.replace(/'/g, "''") : ""}'`;
  }
}
