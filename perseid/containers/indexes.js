import { CSSTransition, TransitionGroup } from "react-transition-group";
import React, { Component } from "react";
import {
  addColumnToIndex,
  deleteIndex,
  fetchIndex,
  fetchTable,
  getAutoGeneratedIndexes,
  removeColumnFromIndex,
  updateIndexColumnProperty,
  updateIndexNames,
  updateIndexProperty
} from "../actions/tables";
import { finishTransaction, startTransaction } from "../actions/undoredo";

import CheckboxCustom from "../components/checkbox_custom";
import CheckboxSwitch from "../components/checkbox_switch";
import { DebounceInput } from "react-debounce-input";
import DetailPanel from "../components/detail_panel";
import Helpers from "../helpers/helpers";
import IndexMongoDb from "../platforms/mongodb/index_mongodb";
import { ModelTypes } from "../enums/enums";
import PGHelpers from "../platforms/pg/helpers_pg";
import Sortable from "react-sortablejs";
import UIHelpers from "../helpers/ui_helpers";
import { UndoRedoDef } from "../helpers/history/undo_redo_transaction_defs";
import _ from "lodash";
import arrayMove from "array-move";
import { bindActionCreators } from "redux";
import { connect } from "react-redux";
import { getHistoryContext } from "../helpers/history/history";
import { navigateToIndexUrl } from "../components/url_navigation";
import { toggleIndexAssistantModal } from "../actions/ui";
import { v4 as uuidv4 } from "uuid";
import { withRouter } from "react-router-dom";

class Indexes extends Component {
  constructor(props) {
    super(props);
    this.handleTextChangePlatform = this.handleTextChangePlatform.bind(this);
    this.handleCheckboxChangePlatform =
      this.handleCheckboxChangePlatform.bind(this);
    this.state = { indexes: [], tableId: undefined };
  }

  componentDidMount() {
    this.updateState();
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      prevProps.tables !== this.props.tables ||
      prevState.tableId !== this.props.match.params.id
    ) {
      this.updateState();
    }
  }

  updateState() {
    const table =
      this.props.match.params.id &&
      this.props.tables[this.props.match.params.id];
    const indexes =
      _.map(table?.indexes, (index) => ({
        index,
        canResetName:
          this.props.type === ModelTypes.PG &&
          this.props.nameAutoGeneration.indexes
            ? PGHelpers.makeIndexName(index, table, this.props.tables) !==
              index.name
            : false
      })) || [];
    this.setState({ indexes, tableId: this.props.match.params.id });
  }

  async handleTextChange(index_id, propName, event) {
    const value = event.target.value;
    this.changeText(index_id, propName, value);
  }

  async changeText(index_id, propName, value) {
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__UPDATE_INDEX_PROPERTY
    );
    try {
      await this.props.updateIndexProperty(
        this.props.match.params.id,
        index_id,
        value,
        propName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleCheckboxChange(index_id, propName, event) {
    const checked = event.target.checked;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__UPDATE_INDEX_PROPERTY_BOOLEAN
    );
    try {
      await this.props.updateIndexProperty(
        this.props.match.params.id,
        index_id,
        checked,
        propName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleSelectChange(index_id, propName, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__UPDATE_INDEX_PROPERTY
    );
    try {
      await this.props.updateIndexProperty(
        this.props.match.params.id,
        index_id,
        value,
        propName
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleColumnInIndexChange(index_id, indexcol_id, event) {
    const value = event.target.value;
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__REMOVE_ADD_COLUMN_TO_INDEX
    );
    try {
      const autoGeneratedIndexes = getAutoGeneratedIndexes(
        {
          type: this.props.type,
          nameAutoGeneration: this.props.nameAutoGeneration
        },
        this.props.tables,
        this.props.tables[this.props.match.params.id]
      );
      var indexToUpdate = _.find(
        this.props.tables[this.props.match.params.id].indexes,
        ["id", index_id]
      );
      var k = _.find(indexToUpdate.cols, ["id", indexcol_id]);

      await this.props.removeColumnFromIndex(
        k.id,
        this.props.match.params.id,
        index_id
      );
      await this.props.addColumnToIndex(
        value,
        this.props.match.params.id,
        index_id
      );

      if (autoGeneratedIndexes.length > 0) {
        await this.props.updateIndexNames(
          this.props.match.params.id,
          autoGeneratedIndexes
        );
      }
    } finally {
      await this.props.finishTransaction();
    }
  }

  initColumnRefPg() {
    return this.props.type === ModelTypes.PG ? { pg: {} } : {};
  }

  initColumnRefSQLite() {
    return this.props.type === ModelTypes.SQLITE
      ? { sqlite: { expression: "" } }
      : {};
  }

  initColumnRefMongoDb() {
    return this.props.type === ModelTypes.MONGODB ? { mongodb: {} } : {};
  }

  openIndexAssistant(indexId) {
    if (this.props.indexAssistantModalIsDisplayed === false) {
      navigateToIndexUrl(
        this.props.match.url,
        this.props.history,
        this.props.match.params.mid,
        this.props.match.params.did,
        this.props.tables[this.props.match.params.id].id,
        this.props.tables[this.props.match.params.id].embeddable,
        indexId
      );
      this.props.toggleIndexAssistantModal();
    }
  }

  async handleColumnInIndexAdd(index_id, event) {
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__COLUMN_IN_INDEX_ADD
    );
    try {
      const autoGeneratedIndexes = getAutoGeneratedIndexes(
        {
          type: this.props.type,
          nameAutoGeneration: this.props.nameAutoGeneration
        },
        this.props.tables,
        this.props.tables[this.props.match.params.id]
      );
      var clnActvTbl = _.cloneDeep(
        this.props.tables[this.props.match.params.id]
      );
      var newItem = {
        id: uuidv4(),
        colid: "0",
        sort: "asc",
        ...this.initColumnRefPg(),
        ...this.initColumnRefSQLite(),
        ...this.initColumnRefMongoDb()
      };
      var ixToUpdate = _.find(clnActvTbl.indexes, ["id", index_id]);
      ixToUpdate.cols = [...ixToUpdate.cols, newItem];
      await this.props.fetchTable(clnActvTbl);
      if (autoGeneratedIndexes.length > 0) {
        await this.props.updateIndexNames(
          this.props.match.params.id,
          autoGeneratedIndexes
        );
      }
    } finally {
      await this.props.finishTransaction();
    }
  }

  initPgIndex() {
    return this.props.type === ModelTypes.PG ? { pg: {}, algorithm: "" } : {};
  }

  initSQLiteIndex() {
    return this.props.type === ModelTypes.SQLITE
      ? { sqlite: {}, algorithm: "" }
      : {};
  }

  initMongoDbIndex() {
    return this.props.type === ModelTypes.MONGODB ? { mongodb: {} } : {};
  }

  async addIndex(event) {
    let persistedEvent = event;
    persistedEvent.preventDefault();

    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__ADD_INDEX
    );

    const tableName = this.props.tables[this.props.match.params.id].name;
    const name =
      this.props.type === ModelTypes.PG && this.props.nameAutoGeneration.indexes
        ? PGHelpers.makeUniqueIndexName(
            tableName,
            [],
            PGHelpers.getAllIndexesByNames(this.props.tables)
          )
        : tableName +
          "_ix_" +
          (_.size(this.props.tables[this.props.match.params.id].indexes) + 1);

    try {
      let idecko = uuidv4();
      var newIndex = {
        id: idecko,
        name,
        unique: false,
        fulltext: false,
        using: "na",
        algorithm: "na",
        lockoption: "na",
        ...this.initPgIndex(),
        ...this.initSQLiteIndex(),
        ...this.initMongoDbIndex(),
        cols: []
      };

      await this.props.fetchIndex(
        newIndex,
        this.props.match.params.id,
        _.size(this.props.tables[this.props.match.params.id].indexes)
      );

      if (
        this.props.type === ModelTypes.MONGODB &&
        this.props.indexAssistantModalIsDisplayed === false
      ) {
        this.openIndexAssistant(newIndex.id);
      }
    } finally {
      await this.props.finishTransaction();
    }
  }

  async deleteIndex(index_id) {
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__DELETE_INDEX
    );
    try {
      var clnActvTbl = _.cloneDeep(
        this.props.tables[this.props.match.params.id]
      );
      let updatedIndexes = clnActvTbl.indexes;
      var index = _.findIndex(updatedIndexes, ["id", index_id]);
      await this.props.deleteIndex(clnActvTbl.id, index);
    } finally {
      await this.props.finishTransaction();
    }
  }

  getIndexDetail() {
    return this.props.tables[this.props.match.params.id].cols.map((col) => {
      return (
        <option value={col.id} key={col.id}>
          {col.name}
        </option>
      );
    });
  }

  async handleTextChangePlatform(indexid, property, platform, event) {
    const value = event.target.value;
    const index = this.props.tables[this.props.match.params.id].indexes.find(
      (ind) => ind.id === indexid
    );
    const current = index[platform];
    const next = {
      ...current,
      [property]: value
    };
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__UPDATE_INDEX_PROPERTY_PLATFORM
    );
    try {
      await this.props.updateIndexProperty(
        this.props.match.params.id,
        indexid,
        next,
        platform
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleCheckboxChangePlatform(indexid, property, platform, event) {
    const checked = event.target.checked;
    const index = this.props.tables[this.props.match.params.id].indexes.find(
      (ind) => ind.id === indexid
    );
    const current = index[platform];
    const next = {
      ...current,
      [property]: checked
    };
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__UPDATE_INDEX_PROPERTY_PLATFORM_BOOLEAN
    );
    try {
      await this.props.updateIndexProperty(
        this.props.match.params.id,
        indexid,
        next,
        platform
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleIndexColChangePlatform(
    indexId,
    indexColumnRefId,
    property,
    bool,
    platform,
    event
  ) {
    const value = bool ? event.target.checked : event.target.value;
    const index = this.props.tables[this.props.match.params.id].indexes.find(
      (ind) => ind.id === indexId
    );
    const columnReference = index.cols.find(
      (colref) => colref.id === indexColumnRefId
    );
    const current = columnReference[platform];
    const next = {
      ...current,
      [property]: value
    };
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__UPDATE_INDEX_COLUMN_PROPERTY
    );
    try {
      await this.props.updateIndexColumnProperty(
        this.props.match.params.id,
        indexId,
        indexColumnRefId,
        next,
        platform
      );
    } finally {
      await this.props.finishTransaction();
    }
  }

  async handleColumnInIndexDelete(index_id, indexcol_id) {
    await this.props.startTransaction(
      getHistoryContext(this.props.history, this.props.match),
      UndoRedoDef.INDEXES__REMOVE_COLUMN_FROM_INDEX
    );
    try {
      const autoGeneratedIndexes = getAutoGeneratedIndexes(
        {
          type: this.props.type,
          nameAutoGeneration: this.props.nameAutoGeneration
        },
        this.props.tables,
        this.props.tables[this.props.match.params.id]
      );
      await this.props.removeColumnFromIndex(
        indexcol_id,
        this.props.match.params.id,
        index_id
      );
      if (autoGeneratedIndexes.length > 0) {
        await this.props.updateIndexNames(
          this.props.match.params.id,
          autoGeneratedIndexes
        );
      }
    } finally {
      await this.props.finishTransaction();
    }
  }

  renderIndexCaptionsPG() {
    return (
      <div className="im-index-detail-grid-pg im-cols-header-fixed">
        <div className="im-bold">
          {_.upperFirst(this.props.localization.L_COLUMNS)}:
        </div>
        <div>Column</div>
        <div>DESC</div>
        <div>NL</div>
        <div />
        <div />
      </div>
    );
  }

  renderIndexCaptionsSQLite() {
    return (
      <div className="im-index-detail-grid-pg im-cols-header-fixed">
        <div className="im-bold">
          {_.upperFirst(this.props.localization.L_COLUMNS)}:
        </div>
        <div>Column</div>
        <div>DESC</div>
        <div />
        <div />
      </div>
    );
  }

  renderIndexColumnItemPG(index, indexcol) {
    return (
      <div key={indexcol.id} className="im-mt-mini">
        <div className="im-index-detail-grid-pg ">
          <div />
          <select
            value={indexcol.colid}
            onChange={this.handleColumnInIndexChange.bind(
              this,
              index.id,
              indexcol.id
            )}
          >
            <option value="0">Select item...</option>
            {this.getIndexDetail()}
          </select>
          <CheckboxCustom
            checked={Helpers.gch(indexcol.pg && indexcol.pg.desc)}
            label=""
            onChange={this.handleIndexColChangePlatform.bind(
              this,
              index.id,
              indexcol.id,
              "desc",
              true,
              "pg"
            )}
          />
          <CheckboxCustom
            checked={Helpers.gch(indexcol.pg && indexcol.pg.nullsLast)}
            label=""
            onChange={this.handleIndexColChangePlatform.bind(
              this,
              index.id,
              indexcol.id,
              "nullsLast",
              true,
              "pg"
            )}
          />
          <div className="handle im-icon-16">&#xe95f;</div>
          <div
            onClick={this.handleColumnInIndexDelete.bind(
              this,
              index.id,
              indexcol.id
            )}
            className="im-icon-sm im-pointer"
          >
            <i className="im-icon-Trash16 im-icon-16" />
          </div>
          <DetailPanel colspan="7">
            <div className="im-index-detail-grid-pg-detail">
              <div>Collate</div>
              <DebounceInput
                type="text"
                debounceTimeout={300}
                className="im-textarea"
                value={indexcol.pg ? Helpers.gv(indexcol.pg.collate) : ``}
                onChange={this.handleIndexColChangePlatform.bind(
                  this,
                  index.id,
                  indexcol.id,
                  "collate",
                  false,
                  "pg"
                )}
              />
              <div>Expression</div>
              <DebounceInput
                type="text"
                debounceTimeout={300}
                className="im-textarea"
                value={indexcol.pg ? Helpers.gv(indexcol.pg.expression) : ``}
                onChange={this.handleIndexColChangePlatform.bind(
                  this,
                  index.id,
                  indexcol.id,
                  "expression",
                  false,
                  "pg"
                )}
              />
            </div>
          </DetailPanel>
        </div>
      </div>
    );
  }

  getIndexColumnsPG(index) {
    return index.cols.length > 0 ? (
      <>
        {this.renderIndexCaptionsPG()}
        {index.cols.map((indexcol) =>
          this.renderIndexColumnItemPG(index, indexcol)
        )}
      </>
    ) : (
      ``
    );
  }

  renderIndexColumnItemSQLite(index, indexcol) {
    return (
      <div key={indexcol.id} className="im-mt-mini">
        <div className="im-index-detail-grid-pg ">
          <div />
          <select
            value={indexcol.colid}
            onChange={this.handleColumnInIndexChange.bind(
              this,
              index.id,
              indexcol.id
            )}
          >
            <option value="0">Select item...</option>
            {this.getIndexDetail()}
          </select>
          <CheckboxCustom
            checked={Helpers.gch(indexcol.sqlite && indexcol.sqlite.desc)}
            label=""
            onChange={this.handleIndexColChangePlatform.bind(
              this,
              index.id,
              indexcol.id,
              "desc",
              true,
              "sqlite"
            )}
          />
          <div className="handle im-icon-16">&#xe95f;</div>
          <div
            onClick={this.handleColumnInIndexDelete.bind(
              this,
              index.id,
              indexcol.id
            )}
            className="im-icon-sm im-pointer"
          >
            <i className="im-icon-Trash16 im-icon-16" />
          </div>
          <DetailPanel colspan="7">
            <div className="im-index-detail-grid-pg-detail">
              <div>Collate</div>
              <DebounceInput
                type="text"
                debounceTimeout={300}
                className="im-textarea"
                value={Helpers.gv(indexcol.sqlite && indexcol.sqlite.collate)}
                onChange={this.handleIndexColChangePlatform.bind(
                  this,
                  index.id,
                  indexcol.id,
                  "collate",
                  false,
                  "sqlite"
                )}
              />
              <div>Expression</div>
              <DebounceInput
                type="text"
                debounceTimeout={300}
                className="im-textarea"
                value={Helpers.gv(
                  indexcol.sqlite && indexcol.sqlite.expression
                )}
                onChange={this.handleIndexColChangePlatform.bind(
                  this,
                  index.id,
                  indexcol.id,
                  "expression",
                  false,
                  "sqlite"
                )}
              />
            </div>
          </DetailPanel>
        </div>
      </div>
    );
  }

  getIndexColumnsSQLite(index) {
    return index.cols.length > 0 ? (
      <>
        {this.renderIndexCaptionsSQLite()}
        {index.cols.map((indexcol) =>
          this.renderIndexColumnItemSQLite(index, indexcol)
        )}
      </>
    ) : (
      ``
    );
  }

  getIndexColumns(index) {
    var i = 0;
    return index.cols.map((indexcol) => {
      i++;
      return (
        <div key={indexcol.id} className="im-index-detail-grid">
          {i === 1 ? (
            <div className="im-bold">
              {_.upperFirst(this.props.localization.L_COLUMNS)}:
            </div>
          ) : (
            <div />
          )}
          <select
            value={indexcol.colid}
            onChange={this.handleColumnInIndexChange.bind(
              this,
              index.id,
              indexcol.id
            )}
          >
            <option value="0">Select item...</option>
            {this.getIndexDetail()}
          </select>

          <div className="handle im-icon-16">&#xe95f;</div>

          <div
            onClick={this.handleColumnInIndexDelete.bind(
              this,
              index.id,
              indexcol.id
            )}
            className="im-icon-sm im-pointer"
          >
            <i className="im-icon-Trash16 im-icon-16" />
          </div>
        </div>
      );
    });
  }

  getIndexMySQLFamilyProps(index) {
    return (
      <div className="im-properties-grid">
        <div>Algorithm: </div>

        <select
          value={index.algorithm}
          onChange={this.handleSelectChange.bind(this, index.id, "algorithm")}
        >
          <option value="na">Not defined</option>
          <option value="DEFAULT">Default</option>
          <option value="INPLACE">INPLACE</option>
          <option value="COPY">COPY</option>
        </select>

        <div>Lock Option: </div>
        <select
          value={index.lockoption}
          onChange={this.handleSelectChange.bind(this, index.id, "lockoption")}
        >
          <option value="na">Not defined</option>
          <option value="DEFAULT">Default</option>
          <option value="NONE">NONE</option>
          <option value="SHARED">SHARED</option>
          <option value="EXCLUSIVE">EXCLUSIVE</option>
        </select>
      </div>
    );
  }

  getIndexExtendedPropertiesPG(index) {
    return (
      <div className="im-mt">
        <div className="im-properties-grid">
          <div />
          <CheckboxSwitch
            label="Unique"
            checked={index.unique}
            onChange={this.handleCheckboxChange.bind(this, index.id, "unique")}
          />
          <div>Using: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            type="text"
            value={Helpers.gv(index.algorithm)}
            onChange={this.handleTextChange.bind(this, index.id, "algorithm")}
          />

          <div>With: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            element="textarea"
            value={Helpers.gv(index.pg && index.pg.storageParameters)}
            onChange={this.handleTextChangePlatform.bind(
              this,
              index.id,
              "storageParameters",
              "pg"
            )}
          />
          <div>Tablespace: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            type="text"
            value={Helpers.gv(index.pg && index.pg.tablespace)}
            onChange={this.handleTextChangePlatform.bind(
              this,
              index.id,
              "tablespace",
              "pg"
            )}
          />
          <div>Expression: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            element="textarea"
            value={Helpers.gv(index.pg && index.pg.expression)}
            onChange={this.handleTextChangePlatform.bind(
              this,
              index.id,
              "expression",
              "pg"
            )}
          />
          <div>Description: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            element="textarea"
            value={Helpers.gv(index.pg && index.pg.desc)}
            onChange={this.handleTextChangePlatform.bind(
              this,
              index.id,
              "desc",
              "pg"
            )}
          />
        </div>
      </div>
    );
  }

  getIndexExtendedPropertiesMongoDb(index) {
    return <IndexMongoDb index={index} />;
  }

  getIndexExtendedPropertiesSQLite(index) {
    return (
      <div className="im-mt">
        <div className="im-properties-grid">
          <div />
          <CheckboxSwitch
            label="Unique"
            checked={index.unique}
            onChange={this.handleCheckboxChange.bind(this, index.id, "unique")}
          />
          <div>Expression: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            element="textarea"
            value={Helpers.gv(index.sqlite && index.sqlite.expression)}
            onChange={this.handleTextChangePlatform.bind(
              this,
              index.id,
              "expression",
              "sqlite"
            )}
          />
          <div>Description: </div>
          <DebounceInput
            minLength={1}
            debounceTimeout={300}
            element="textarea"
            value={Helpers.gv(index.sqlite && index.sqlite.desc)}
            onChange={this.handleTextChangePlatform.bind(
              this,
              index.id,
              "desc",
              "sqlite"
            )}
          />
        </div>
      </div>
    );
  }

  getIndexExtendedPropertiesMySQLFamily(index) {
    return (
      <div className="im-mt">
        <div className="im-properties-grid">
          <div>Using: </div>

          <select
            value={index.using}
            onChange={this.handleSelectChange.bind(this, index.id, "using")}
          >
            <option value="na">Not defined</option>
            <option value="BTREE">BTREE</option>
            <option value="HASH">HASH</option>
          </select>
        </div>

        {this.getIndexMySQLFamilyProps(index)}

        <div className="im-properties-grid">
          <div />
          <div>
            <CheckboxSwitch
              label="Unique"
              checked={index.unique}
              onChange={this.handleCheckboxChange.bind(
                this,
                index.id,
                "unique"
              )}
            />

            <CheckboxSwitch
              label="Fulltext"
              checked={index.fulltext}
              onChange={this.handleTextChange.bind(this, index.id, "fulltext")}
            />
          </div>
        </div>
      </div>
    );
  }

  getIndexesClass() {
    return this.props.type === ModelTypes.PG &&
      this.props.nameAutoGeneration.indexes
      ? "im-keys-grid-pg"
      : "im-keys-grid";
  }

  async resetIndexName(index_id, canResetName) {
    if (!canResetName) {
      return;
    }
    const table =
      this.props.match.params.id &&
      this.props.tables[this.props.match.params.id];
    const index = _.find(table.indexes, ["id", index_id]);
    const value = PGHelpers.makeIndexName(index, table, this.props.tables);
    this.changeText(index_id, "name", value);
  }

  renderResetName(index, canResetName) {
    const className =
      "im-has-tooltip im-relative  im-pointer im-icon-sm" +
      (canResetName ? "" : " im-disabled");
    const classNameImage =
      "im-icon-ResetName im-icon-16" + (canResetName ? "" : " im-disabled");
    return this.props.type === ModelTypes.PG &&
      this.props.nameAutoGeneration.indexes ? (
      <div
        className={className}
        onClick={this.resetIndexName.bind(this, index.id, canResetName)}
      >
        <i className={classNameImage} />
        <div className={"im-tooltip im-tooltip-right"}>Reset name</div>
      </div>
    ) : (
      <></>
    );
  }

  renderIndexes() {
    return this.state.indexes.map(({ index, canResetName }) => {
      return (
        <CSSTransition
          key={index.id}
          classNames="example"
          timeout={{ enter: 500, exit: 300 }}
        >
          <div key={index.id} className={this.getIndexesClass()}>
            <div />
            <DebounceInput
              minLength={1}
              debounceTimeout={300}
              type="text"
              size="2"
              value={index.name}
              onChange={this.handleTextChange.bind(this, index.id, "name")}
            />

            {this.props.type === ModelTypes.MONGODB ? (
              <div
                className="im-pointer im-icon-sm"
                onClick={this.openIndexAssistant.bind(this, index.id)}
              >
                <i className="im-icon-Edit16 im-icon-16" />
              </div>
            ) : (
              <></>
            )}

            <div
              className="im-pointer im-icon-sm"
              onClick={this.deleteIndex.bind(this, index.id)}
            >
              <i className="im-icon-Trash16 im-icon-16" />
            </div>

            {this.renderResetName(index, canResetName)}
            <DetailPanel colspan="4">
              <div className="im-new-item-wrapper">
                {this.props.type === ModelTypes.MONGODB ? (
                  this.props.indexAssistantModalIsDisplayed === false ? (
                    <button
                      className="im-btn-default im-btn-sm im-sub"
                      onClick={this.openIndexAssistant.bind(this, index.id)}
                    >
                      Open new index assistant
                    </button>
                  ) : (
                    <></>
                  )
                ) : (
                  <button
                    className="im-btn-default im-btn-sm im-sub"
                    onClick={this.handleColumnInIndexAdd.bind(this, index.id)}
                  >
                    + Add {_.upperFirst(this.props.localization.L_COLUMN)} to
                    Index
                  </button>
                )}
              </div>
              <Sortable
                options={{
                  handle: ".handle"
                }}
                onChange={async (order, sortable, evt) => {
                  await this.props.startTransaction(
                    getHistoryContext(this.props.history, this.props.match),
                    UndoRedoDef.INDEXES__REORDER
                  );
                  try {
                    const autoGeneratedIndexes = getAutoGeneratedIndexes(
                      {
                        type: this.props.type,
                        nameAutoGeneration: this.props.nameAutoGeneration
                      },
                      this.props.tables,
                      this.props.tables[this.props.match.params.id]
                    );
                    var newSort = arrayMove(
                      index.cols,
                      evt.oldIndex -
                        (this.props.type === ModelTypes.PG ||
                        this.props.type === ModelTypes.SQLITE
                          ? 1
                          : 0),
                      evt.newIndex -
                        (this.props.type === ModelTypes.PG ||
                        this.props.type === ModelTypes.SQLITE
                          ? 1
                          : 0)
                    );
                    var newIndex = Object.assign({}, index);
                    newIndex.cols = newSort;

                    var clnActvTbl = _.cloneDeep(
                      this.props.tables[this.props.match.params.id]
                    );
                    var ixToUpdate = _.find(clnActvTbl.indexes, [
                      "id",
                      index.id
                    ]);
                    ixToUpdate.cols = newSort;

                    await this.props.fetchTable(clnActvTbl);
                    if (autoGeneratedIndexes.length > 0) {
                      await this.props.updateIndexNames(
                        this.props.match.params.id,
                        autoGeneratedIndexes
                      );
                    }
                  } finally {
                    await this.props.finishTransaction();
                  }
                }}
              >
                {this.props.type === ModelTypes.PG
                  ? this.getIndexColumnsPG(index)
                  : this.props.type === ModelTypes.SQLITE
                  ? this.getIndexColumnsSQLite(index)
                  : this.getIndexColumns(index)}
              </Sortable>
              {this.props.type === ModelTypes.MARIADB ||
              this.props.type === ModelTypes.MYSQL ? (
                this.getIndexExtendedPropertiesMySQLFamily(index)
              ) : this.props.type === ModelTypes.PG ? (
                this.getIndexExtendedPropertiesPG(index)
              ) : this.props.type === ModelTypes.MONGODB ? (
                this.getIndexExtendedPropertiesMongoDb(index)
              ) : this.props.type === ModelTypes.SQLITE ? (
                this.getIndexExtendedPropertiesSQLite(index)
              ) : (
                <></>
              )}
            </DetailPanel>
          </div>
        </CSSTransition>
      );
    });
  }

  render() {
    return (
      <div>
        <div className="im-new-item-wrapper">
          <button
            className="im-btn-default im-btn-sm"
            onClick={this.addIndex.bind(this)}
          >
            + Add Index
          </button>
        </div>
        {_.size(this.props.tables[this.props.match.params.id].indexes) > 0
          ? UIHelpers.getHeader("Index name")
          : null}
        <TransitionGroup>{this.renderIndexes()}</TransitionGroup>
      </div>
    );
  }
}

function mapStateToProps(state) {
  return {
    type: state.model.type,
    nameAutoGeneration: state.model.nameAutoGeneration,
    tables: state.tables,
    localization: state.localization,
    indexAssistantModalIsDisplayed: state.ui.indexAssistantModalIsDisplayed
  };
}

function mapDispatchToProps(dispatch) {
  return {
    ...bindActionCreators(
      {
        fetchTable,
        fetchIndex,
        deleteIndex,
        updateIndexProperty,
        addColumnToIndex,
        removeColumnFromIndex,
        updateIndexColumnProperty,
        toggleIndexAssistantModal,
        finishTransaction,
        startTransaction,
        updateIndexNames
      },
      dispatch
    ),
    dispatch
  };
}

export default withRouter(
  connect(mapStateToProps, mapDispatchToProps)(Indexes)
);
