import { RelationToSQLModel } from "../../../generator/model-to-sql-model/relation_to_sql_model";
import { ScopeType } from "../../../generator/model-to-sql-model/sql_model_builder";
import {
  INCLUDE_GENERATED_NAMES_ALWAYS,
  INCLUDE_GENERATED_NAMES_CUSTOM_NAMES_ONLY
} from "../../../generator/sql-model-to-lines/model_to_lines";
import PGHelpers from "../helpers_pg";

const KEYWORDS = {
  COMMENT: `COMMENT`,
  CONSTRAINT: `CONSTRAINT`,
  IS: `IS`,
  ON: `ON`
};

/**
 * Convert model to SQL model
 * ALTER TABLE or constraint
 */
export class RelationToSQLModelPG extends RelationToSQLModel {
  objectStatements() {
    return [...super.objectStatements(), this.commentStatement()];
  }

  isConstraintNameAutoGenerated() {
    return (
      PGHelpers.makeRelationName(this.relation, this.tables, this.relations) !==
      this.relation.name
    );
  }

  shouldAddConstraintName() {
    switch (this.generatorOptions.includeGeneratedNames) {
      case INCLUDE_GENERATED_NAMES_ALWAYS:
        return !!this.relation.name;
      case INCLUDE_GENERATED_NAMES_CUSTOM_NAMES_ONLY:
        return this.isConstraintNameAutoGenerated();
      default:
        return false;
    }
  }

  constraint() {
    return [
      ...(this.shouldAddConstraintName()
        ? [
            this.sb.keyword(KEYWORDS.CONSTRAINT),
            this.sb.identifier(this.relation.name, false, ScopeType.SUBOBJECT)
          ]
        : []),
      this.foreignKeyBlock()
    ];
  }

  commentStatement(
    type,
    constraintIdentifier,
    tableQualifiedIdentifier,
    comment
  ) {
    return comment
      ? this.sb.statement(
          this.sb.keyword(KEYWORDS.COMMENT),
          this.sb.keyword(KEYWORDS.ON),
          this.sb.keyword(type),
          constraintIdentifier,
          this.sb.keyword(KEYWORDS.ON),
          tableQualifiedIdentifier,
          this.sb.keyword(KEYWORDS.IS),
          this.sb.quotedLiteral(comment),
          this.sb.statementDelimiter(false)
        )
      : undefined;
  }
}
